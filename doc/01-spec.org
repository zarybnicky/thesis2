* (front matter)                                              :ignoreheading:
#+LANGUAGE: en
#+OPTIONS: texht:nil toc:nil author:nil ':t H:4 num:3
#+LATEX_CLASS: fitthesis
#+LATEX_CLASS_OPTIONS: [english,zadani,odsaz]
#+EXCLUDE_TAGS: noexport
#+BIND: org-latex-title-command ""
#+BIND: org-latex-prefer-user-labels t
#+BIND: org-latex-default-figure-position "htb"

#+latex: \setcounter{chapter}{1}

* Language specification: λ⋆-calculus with extensions
  :PROPERTIES:
  :CUSTOM_ID: lambda
  :END:
** Introduction
Proof assistants like Agda or Idris are built around a fundamental principle
called the Curry-Howard correspondence that connects type theory and
mathematical logic, demonstrated in Figure ref:ch-logic. In simplified terms it
says that given a language with a self-consistent type system, writing a
well-typed program is equivalent to proving its correctness
cite:baez10_rosetta. It is often shown on the correspondence between natural
deduction and the simply-typed λ-calculus, as in Figure ref:ch-deduction. Proof
assistants often have a small core language around which they are built:
e.g. Coq is built around the Calculus of Inductive Constructions, which is a
higher-order typed λ-calculus.

#+label: ch-logic
#+CAPTION: Curry-Howard correspondence between mathematical logic and type theory
#+ATTR_LaTeX: :options [!htb]
#+begin_figure latex
\captionsetup{aboveskip=-3pt}
\begin{center}
\begin{tabular}{c|c}
Mathematical logic & Type theory \\\hline\\[-1em]
\shortstack{$⊤$ \\ true} &
\shortstack{$()$ \\ unit type} \\
\shortstack{$⊥$ \\ false} &
\shortstack{$∅$ \\ empty type} \\[7pt]
\shortstack{$p ∧ q$ \\ conjunction} &
\shortstack{$a × b$ \\ product type} \\[7pt]
\shortstack{$p ∨ q$ \\ disjunction} &
\shortstack{$a + b$ \\ sum type} \\[7pt]
\shortstack{$p ⇒ q$ \\ implication} &
\shortstack{$a → b$ \\ exponential (function) type} \\[9pt]
\shortstack{$∀x ∈ A, p$ \\ universal quantification} &
\shortstack{$Π_{x : A}B(x)$ \\ dependent product type} \\[9pt]
\shortstack{$∃x ∈ A, p$ \\ existential quantification} &
\shortstack{$Σ_{x : A}B(x)$ \\ dependent sum type}
\end{tabular}
\end{center}
#+end_figure

#+label: ch-deduction
#+CAPTION: Curry-Howard correspondence between sequent calculus and λ→-calculus
#+ATTR_LaTeX: :options [!htb]
#+begin_figure latex
\captionsetup{aboveskip=-5pt}
\begin{center}
\begin{tabular}{c|c}
Sequent calculus & λ→-calculus \\\hline\\
\shortstack{
\AxiomC{}
\UnaryInfC{$Γ₁, α, Γ₂ ⊢ α$}
\DisplayProof \\ axiom} &
\shortstack{
\AxiomC{}
\UnaryInfC{$Γ₁, x : α, Γ₂ ⊢ x : α$}
\DisplayProof \\ variable} \\[7pt]

\shortstack{
\AxiomC{$Γ, α ⊢ β$}
\UnaryInfC{$Γ ⊢ α ⇒ β$}
\DisplayProof \\ implication introduction} &
\shortstack{
\AxiomC{$Γ, x : α ⊢ t : β$}
\UnaryInfC{$Γ ⊢ λx. t: α ⇒ β$}
\DisplayProof \\ abstraction} \\[7pt]

\shortstack{
\AxiomC{$Γ ⊢ α ⇒ β$}
\AxiomC{$Γ ⊢ α$}
\BinaryInfC{$Γ ⊢ β$}
\DisplayProof \\ modus ponens} &
\shortstack{
\AxiomC{$Γ ⊢ t : α → β$}
\AxiomC{$Γ ⊢ u : α$}
\BinaryInfC{$Γ ⊢ t u : β$}
\DisplayProof \\ application} \\[7pt]
\end{tabular}
\end{center}
#+end_figure

Compared to the type systems in languages like Java, dependent type systems can
encode much more information in types. We can see the usual example of a list
with a known length in Listing ref:idris-vect: the type ~Vect~ has two parameters,
one is the length of the list, the other is the type of its elements. Using such
a type we can define safe indexing operators like ~head~, which is only applicable
to non-empty lists, or ~index~, where the index must be in the list (~Fin
len~). List concatenation uses arithmetic on the type level, and it is possible
to explicitly prove that concatenation preserves list length.

#+label: idris-vect
#+caption: Vectors with explicit length in the type\protect\footnotemark
#+begin_src idris
  data Vect : (len : Nat) -> (elem : Type) -> Type where
    Nil  : Vect Z elem
    (::) : (x : elem) -> (xs : Vect len elem) -> Vect (S len) elem

  -- Definitions elided
  head : Vect (S len) elem -> elem
  index : Fin len -> Vect len elem -> elem
  (++) : (xs : Vect m elem) -> (ys : Vect n elem) -> Vect (m + n) elem
  proofConcatLength
    : {m, n : Nat} -> {A : Type} -> (xs : Vect n A) -> (ys : Vect m A)
      -> length (xs ++ ys) = length xs + length ys
#+end_src
#+latex: \footnotetext{Adapted from the Idris \texttt{base} library: \url{https://github.com/idris-lang/Idris-dev/blob/master/libs/base/Data/Vect.idr}}

On the other hand, these languages are often restricted in some ways. General
Turing-complete languages allow non-terminating programs: non-termination leads
to a inconsistent type system, so proof assistants use various ways of keeping
the logic sound and consistent. Idris, for example, requires that functions are
total and finite. It uses a termination checker, checking that recursive
functions use only structural or primitive recursion, in order to ensure that
type-checking stays decidable.

This chapter aims to introduce the concepts required to specify the syntax and
semantics of a small dependently-typed language and use these to produce such a
specification, a necessary prerequisite so that we can create interpreters for
this language in later chapters. This chapter, however, does not attempt to be a
complete reference in the large field of type theory.

** Languages
Type theories with dependent types are based on typed λ-calculi. To introduce
them well, we first need to go through the syntax and semantics of simpler
languages, starting with the untyped λ-calculus. This section summarizes the
necessary concepts, drawing primarily from Barendregt cite:barendregt92_typed.

*** λ-calculus
Introduced in the 1930s by Alonzo Church, the untyped λ-calculus was intended as
a simple model of computation. It is a Turing-complete system, but only consists
of three constructions: abstraction, application, and variables. Figure
ref:untyped demonstrates two possible notations for the untyped λ-calculus. We
will use the standard Church notation, with right associativity of abstraction,
and left associativity of application, application binding stronger than
abstraction: in any following examples, an expression like $λx.λy.x y z$ would
be parenthesized to $λx.(λy.((x y) z))$.

#+label: untyped
#+CAPTION: Syntax of the λ-calculus using Church and de Bruijn notation
#+ATTR_LaTeX: :options [htb]
#+begin_figure latex
\begin{subfigure}[t]{.5\textwidth}\centering
  \[\begin{array}{ccll}
  e & ::= & v   & \text{variable} \\
    & |   & M~N & \text{application} \\
    & |   & λv.~M & \text{abstraction}
  \end{array}\]
  \caption{Standard (Church) notation}
\end{subfigure}
\begin{subfigure}[t]{.5\textwidth}\centering
  \[\begin{array}{ccll}
  e & ::= & v     \\
    & |   & (N)~M \\
    & |   & [v]~M
  \end{array}\]
  \caption{De Bruijn notation}
\end{subfigure}
#+end_figure

**** β-reduction
A /λ-abstraction/ corresponds to the common notion of a function in programming
languages. The λ-abstraction $λx.t$ consists of a binder $λx$, and a body
$t$. /Applying/ a λ-abstraction to an argument, e.g., $(λx.x) t$, corresponds to
evaluating a function, and returns the result of evaluating the body. In
λ-calculus, evaluating the body of a function is called /substitution/. It is
written $t[x≔T]$ and means that all occurrences of the variable $x$ are replaced
with the term $T$ inside a term $t$. The application of a λ-abstraction to a
term is called a /β-reduction/, and it is the basic /rewrite rule/ of λ-calculus.

#+LATEX: \[ (λx. t) u ⟶_β t[x≔u] \]

**** α-conversion
If a variable inside the body of a λ-abstraction is mentioned in any binders, it
is called bound, e.g., the variable $x$ is bound in $λx.λy.x$. Conversely, all
unbound variables are called /free/, e.g., the variable $z$ is a free variable
$λx.z$. When performing a substitution, no free variable can become bound, as
the term would change its meaning. We need to ensure that the variable names in
the terms do not overlap and rename them if they do. The process of renaming
variables is called /α-conversion/ (α-renaming) and, in general, may need to
happen before each β-reduction.

#+LATEX: \[ (λx. t) ⟶_α (λy. t[x≔y]) \]

**** η-conversion
Reducing a λ-abstraction that directly applies its argument to a term or
equivalently, rewriting a term in the form of $λx.f x$ to $f$ is called
/η-reduction/. The opposite rewrite rule, from $f$ to $λx.f x$ is
$\bar{η}\text{-expansion}$, and because the rewriting works in both ways, they
are together called the /η-conversion/.

#+LATEX: \[ λx.f x ⟶_η f\]  \[ f ⟶_{\bar{η}} λx.f x \]

**** δ-reduction
β-reduction together with α-renaming are sufficient to specify λ-calculus, but
there are three other rewriting rules that we will need later: /δ-reduction/ is
the replacement of a constant with its definition, e.g., given a constant $id$
with the definition $λx.x$, the expression $id t$ would be δ-reduced to
$(λx.x) t$.

#+LATEX: \[ id t ⟶_δ (λx.x) t\]

**** ζ-reduction
If we extend the syntax of the language with a $let-in$ construct that defines a
local variable, equivalent process to δ-reduction applied to local variable is
called the /ζ-reduction/.

#+LATEX: \[ let id = λx.x in id t ⟶_ζ (λx.x) t \]

**** ι-reduction
Later, we will also use other types of objects than just functions. Applying a
function that extracts a value from an object is called the /ι-reduction/. In this
example, the object is a pair of values, and the function $π₁$ is a primitive
operation that extracts the first value of the pair.

#+LATEX: \[ π₁ (a, b) ⟶_ι a \]

**** Normal form
Applying a reduction until a term can no longer be reduced produces a normal
form: β-reduction leads to a β-normal form, β- and δ-reductions produce the
βδ-normal form. All of these reduction together: applying functions to their
arguments, replacing constants and local variables with their definitions,
evaluating objects, and α-converting variables if necessary are called
βδιζ-reduction, and produce a βδιζ-normal form, or just /normal form/ for
short. Every term of the λ-calculus has only a single unique normal form (up to
α-conversion), according to the Church-Rossier theorem.

#+begin_export latex
\[\begin{array}{rl}
     & \text{let} pair = λm.(m,m) \text{in} π₁ (pair (id 5)) \\
⟶_ζ & π₁ ((λm.(m,m)) (id 5)) \\
⟶_β & π₁ (id 5, id 5) \\
⟶_ι & id 5 \\
⟶_δ & (λx.x) 5 \\
⟶_β & 5 \\
\end{array}\]
#+end_export

**** Other normal forms
A full normal form has all sub-terms of a term fully reduced. There are also
other normal forms, that differ in the treatment of bodies of λ-abstractions.If
we have an expression and repeatedly only use the β-reduction, we end up with a
function, or a variable applied to some free variables. These other normal forms
specify what happens in such a "stuck" case. In Figure ref:normal-forms, $e$ is
an arbitrary λ-term and $E$ is a term in the relevant normal form
cite:sestoft02_reduction. Closely related to the concept of a normal form are
/normalization strategies/ that specify the order in which sub-expressions are
reduced.

#+LATEX:{\renewcommand{\arraystretch}{1.3}%
#+LABEL: normal-forms
#+CAPTION: Normal forms in λ-calculus
#+begin_figure latex
\captionsetup{aboveskip=-1pt}
\begin{center}
\begin{tabular}{ccll}
& & \multicolumn{2}{c}{Reduce under abstraction} \\\cline{3-4}
& \multicolumn{1}{c|}{} & \textbf{Yes} & \multicolumn{1}{|c|}{\textbf{No}}
\\\cline{2-4}
\multicolumn{1}{c|}{\multirow{4}{*}{\rotatebox[origin=c]{90}{Reduce args}}} &
\multicolumn{1}{c|}{\multirow{2}{*}{\textbf{Yes}}}
& $E ≔ λx.E | x E₁...Eₙ$ & \multicolumn{1}{|l|}{$E ≔ λx.e | x E₁...Eₙ$}
\\
\multicolumn{1}{c|}{} & \multicolumn{1}{c|}{}
& Normal form  & \multicolumn{1}{|l|}{Weak normal form}
\\\cline{2-4}
\multicolumn{1}{c|}{} & \multicolumn{1}{c|}{\multirow{2}{*}{\textbf{No}}}
& $E ≔ λx.E | x e₁...eₙ$ & \multicolumn{1}{|l|}{$E ≔ λx.e | x e₁...eₙ$}
\\
\multicolumn{1}{c|}{} & \multicolumn{1}{c|}{}
& Head normal form & \multicolumn{1}{|l|}{Weak head normal form}
\\\cline{2-4}
\end{tabular}
\end{center}
#+end_figure
#+LATEX: }

**** Strong normalization
An important property of a model of computation is termination, the question of
whether there are expressions for which computation does not stop. In the
context of λ-calculus it means whether there are terms, where repeatedly
applying rewriting rules does not produce a unique normal form in a finite
sequence steps. While for some expressions this may depend on the selected
rewriting strategy, the general property is as follows: If for all well-formed
terms $a$ there does not exist any infinite sequence of reductions $a ⟶_{β}
a' ⟶_{β} a''⟶_{β} ⋯$, then such a system is called /strongly normalizing/.

The untyped λ-calculus is not a strongly normalizing system, though, and there
are expressions that do not have a normal form. When such expressions are
reduced, they do not get smaller, but they /diverge/. The ω combinator:

#+LATEX: \[ω = λx.x~x\]

is one such example that produces an infinite term. Applying ω to itself
produces a divergent term whose reduction cannot terminate:

#+LATEX: \[ω~ω ⟶_δ (λx.x x)ω ⟶_β ω~ω\]

The fixed-point function, the Y combinator, is also notable:

#+LATEX: \[Y = λf.(λx.f(x x)) (λx.f(x x))\]

This is one possible way of encoding general recursion in λ-calculus, as it
reduces by applying $f$ to itself:

#+LATEX: \[Y f ⟶_{δβ} f(Y f) ⟶_{δβ} f(f(Y f))  ⟶_{δβ} ...\]

This, as we will see in the following chapter, is impossible to encode in the
typed λ-calculus without additional extensions.

As simple as λ-calculus may seem, it is a Turing-complete system that can encode
logic, arithmetic, or data structures. Some examples include /Church encoding/ of
booleans, pairs, or natural numbers (Figure ref:church).

#+LABEL: church
#+CAPTION: Church encoding of various concepts
#+ATTR_LaTeX: :options [!htb]
#+begin_figure latex
\captionsetup{aboveskip=13pt}
\begin{subfigure}[b]{.5\textwidth}\centering
  \[\begin{array}{ccl}
  0 & = & λf.λx.~x \\
  1 & = & λf.λx.~f~x
  \end{array}\]
  \caption{Natural numbers}
\end{subfigure}
\begin{subfigure}[b]{.5\textwidth}\centering
  \[\begin{array}{ccll}
  succ & = & λn.λf.λx.f~(n~f~x) \\
  plus & = & λm.λn.m~succ~n
  \end{array}\]
  \caption{Simple arithmetic}
\end{subfigure}
\begin{subfigure}[b]{.5\textwidth}\centering
  \[\begin{array}{ccll}
  true & = & λx.λy.x \\
  false & = & λx.λy.y \\
  not & = & λp.p~false~true \\
  and & = & λp.λq.p~q~p \\
  ifElse & = & λp.λa.λb.p~a~b
  \end{array}\]
  \caption{Logic}
\end{subfigure}
\begin{subfigure}[b]{.5\textwidth}\centering
  \[\begin{array}{ccll}
  cons & = & λf.λx.λy.f~x~y \\
  fst & = & λp.p~true \\
  snd & = & λp.p~false \\
  \end{array}\]
  \caption{Pairs}
\end{subfigure}
#+end_figure

*** λ→-calculus
It is often useful to describe the kinds of objects we work with,
though. Already, in Figure ref:church we could see that reading such expressions
can get confusing: a boolean is a function of two parameters, whereas a pair is
a function of three arguments, of which the first one needs to be a boolean and
the other two contents of the pair.

The untyped λ-calculus defines a general model of computation based on functions
and function application. Now we will restrict this model using types that
describe the values that can be computed with.

The simply typed λ-calculus introduces the concept of types. There are two
separate languages languages: the language of terms, and the language of
types. These languages are connected by a /type judgment/, or /type assignment/ $x :
T$ that asserts that the term $x$ has the type $T$
cite:guallart15_overview_types. It also called the λ→-calculus, as "→" is the
connector used in types. We have a set of basic types that are connected into
terms using the arrow →, and type annotation or assignment $x : A$.

**** Church- and Curry-style
There are two ways of formalizing the simply-typed λ-calculus: λ→-Church, and
λ→-Curry. Church-style is also called system of typed terms, or the explicitly
typed λ-calculus, as λ-abstractions directly include the type of the argument in
the binder, and we say:

#+LATEX: \[λx : A.x : A → A,\]

or using parentheses to clarify the precedence

#+LATEX: \[λ(x : A).x : (A → A).\]

Curry-style is also called the system of typed assignment, or the implicitly
type λ-calculus as we assign types to untyped λ-terms that do not carry type
information by themselves, and we say $λx.x : A → A$ cite:barendregt92_typed.

There are systems that are not expressible in Curry-style, and vice versa.
Curry-style is interesting for programming, we want to omit type information;
and we will see how to manipulate programs specified in this way in Chapter
ref:interpreter. We will use Church-style in this chapter, but our language will
be Curry-style, so that we incorporate elaboration into the interpreter.

**** Well-typed terms
Before we only needed evaluation rules to fully specify the system, but
specifying a system with types also requires typing rules that describe what
types are allowed. We will also need to distinguish /well-formed terms/ from
/well-typed terms/: well-formed terms are syntactically valid, whereas well-typed
terms also obey the typing rules. Terms that are well-formed but not yet known
to be well typed are called /pre-terms/ (pre-syntax).

These properties are ensured by type-checking algorithms that will be described
in detail in the next chapter. In brief: given a pre-term and a type, /type
checking/ verifies if the term can be assigned the type; given just a pre-term
and no type, /type inference/ computes the type of an expression; and finally /type
elaboration/ is the process of converting a partially specified pre-term into a
complete, well-typed term using the previous two cite:ferreira14_bidi.

#+label: simple-syntax
#+CAPTION: λ→-calculus syntax
#+ATTR_LaTeX: :options [hbt]
#+begin_figure latex
\captionsetup{aboveskip=-5pt}
\[\begin{array}{ccll}
e & & & \textit{(terms)} \\
  & ≔ & v     & \text{variable} \\
  & | & M~N   & \text{application} \\
  & | & λx.~t & \text{abstraction} \\
  & | & x:τ   & \text{annotation} \\[5pt]
τ & & & \textit{(types)} \\
  & ≔ & β      & \text{base types} \\
  & | & τ → τ' & \text{composite type} \\[5pt]
Γ & & & \textit{(typing context)} \\
  & ≔ & ∅     & \text{empty context} \\
  & | & Γ,x:τ & \text{type judgement} \\[5pt]
v & & & \textit{(values)} \\
  & ≔ & λx. t & \text{closure} \\[5pt]
\end{array}\]
#+end_figure

**** Types and context
The complete syntax of the λ→-calculus is in Figure ref:simple-syntax.  This
time, we also include the notion of /values/, which are the result of fully
reducing an expression. As there are only functions in this variant, the only
possible value is a closure: a partially-evaluated function. Reduction
operations are the same as in the untyped lambda calculus, but we will need to
add the language of types to the previously specified language of terms.

The language of types consists of a set of /base types/ which can consist of
e.g. natural numbers or booleans, and /composite types/, which describe functions
between them. We also need a way to store the types of terms that are known, a
typing /context/, which consists of a list of /type judgments/ in the form $x:T$,
which associate variables to their types.

#+label: simple-types
#+CAPTION: λ→-calculus typing rules
#+ATTR_LaTeX: :options [!htb]
#+begin_figure latex
\captionsetup{aboveskip=-3pt}
\begin{prooftree}
\AxiomC{$x : A ∈ Γ$}
\RightLabel{\textsc{(Var)}}
\UnaryInfC{$Γ ⊢ x : A$}
\end{prooftree}
\begin{prooftree}
\AxiomC{$Γ ⊢ f:A→B$}
\AxiomC{$Γ ⊢ a:A$}
\RightLabel{\textsc{(App)}}
\BinaryInfC{$Γ ⊢ fa : B$}
\end{prooftree}
\begin{prooftree}
\AxiomC{$Γ,x : A ⊢ b:B$}
\RightLabel{\textsc{(Abs)}}
\UnaryInfC{$Γ ⊢ λx : A. b : A→B$}
\end{prooftree}
#+end_figure

**** Typing rules
The simply-typed λ-calculus can be completely specified by the typing rules in
Figure ref:simple-types cite:pierce02_types. These rules are read similarly to
logic proof trees: as an example, the rule *App* can be read as "if we can infer
$f$ with the type $A→B$ and $a$ with the type $A$ from the context Γ, then we
can also infer that function application $f a$ has the type $B$". Given these
rules and the formula

#+LATEX: \[λa:A.λb:B.a : A→B→A\]

we can also produce a derivation tree that looks similar to logic proofs and, as
mentioned before, its semantics corresponding to the logic formula "if $A$ and $B$,
then $A$" as per the Curry-Howard equivalence.

#+begin_export latex
\begin{prooftree}
\AxiomC{}
\UnaryInfC{$a:A, b:B ⊢ a:A$}
\UnaryInfC{$a:A ⊢ λb:B. a : B→A$}
\UnaryInfC{$⊢ λa:A. λb:B. a : A→B→A$}
\end{prooftree}
#+end_export

We briefly mentioned the problem of termination in the previous section; the
simply-typed λ-calculus is strongly normalizing: the reduction of any well-typed
term of the λ→-calculus will terminate, and produce a unique normal form. In
other words, there is no way of writing a divergent term that is also
well-typed; the Y combinator is impossible to type in λ→ and any of the systems
in the next chapter cite:bove08_atwork.

*** λ-cube
The λ→-calculus restricts the types of arguments to functions; types are static
and descriptive. When evaluating a well-typed term, the types can be erased
altogether without any effect on the computation. In other words, terms can only
depend on other terms.

Generalizations of the λ→-calculus can be organized into a cube called the
Barendregt cube, or the λ-cube cite:barendregt92_typed (Figure ref:cube). In λ→
only terms depend on terms, but there are also three other combinations
represented by the three dimensions of the cube: types depending on types
$(□,□)$, or also called type operators; types depending on terms $(□,⋆)$, called
/polymorphism/; and terms depending on types $(⋆,□)$, representing /dependent
types/.

#+label: cube
#+CAPTION: Barendregt cube (also λ-cube)
#+ATTR_LATEX: :options [!htb]
#+begin_figure latex
\captionsetup{aboveskip=-1pt}
\centering
\begin{tikzpicture}
\matrix (m) [matrix of math nodes,
row sep=2.5em, column sep=2.5em,
text height=1.5ex,
text depth=0.25ex]{
   & λω             &     & λΠω            \\
λ2 &                & λΠ2 &                \\
   & λ\underline{ω} &     & λΠ\underline{ω}\\
λ→ &                & λΠ  \\
};
\path[-{Latex[length=2.5mm, width=1.5mm]}]
(m-1-2) edge (m-1-4)
(m-2-1) edge (m-2-3) edge node[fill=white,pos=0.4]{$(□,□)$} (m-1-2)
(m-3-2) edge (m-1-2) edge (m-3-4)
(m-4-1) edge node[fill=white]{$(□,⋆)$} (m-2-1)
(m-4-1) edge (m-3-2)
(m-4-1) edge node[fill=white]{$(⋆,□)$} (m-4-3)
(m-3-4) edge (m-1-4)
(m-2-3) edge (m-1-4)
(m-4-3) edge (m-3-4) edge (m-2-3);
\end{tikzpicture}
#+end_figure
#+LATEX: \vspace*{-.5cm}

**** Sorts
To formally describe the cube, we will need to introduce the notion of sorts. In
brief,

#+LATEX: \[t : T : ⋆ : □.\]

The meaning of the symbol $:$ is same as before, "x has type y". The type of a
term $t$ is a type $T$, the type of a type $T$ is a kind $*$, and the type of
kinds is the sort □. The symbols ⋆ and □ are called /sorts/. As with types, sorts
can be connected using arrows, e.g. $(⋆→⋆)→⋆$. To contrast the syntaxes of the
following languages, the syntax of λ→ is here:

#+begin_export latex
\[\begin{array}{ccccccc}
types & ≔ & T & | & A → B  &   &     \\
terms & ≔ & v & | & λx:A.t & | & a b \\
values & ≔ &  &   & λx:A.t &   & \\
\end{array}\]
#+end_export

**** λ\underline{ω}-calculus
Higher-order types or type operators generalizes the concepts of functions to
the type level, adding λ-abstractions and applications to the language of types.

#+begin_export latex
\[\begin{array}{ccccccccc}
types & ≔ & T & | & A → B  & | & A B & | & ΛA.B(a) \\
terms & ≔ & v & | & λx:A.t & | & a b \\
values & ≔ &  &   & λx:A.t \\
\end{array}\]
#+end_export

**** λ2-calculus
The dependency of terms on types adds polymorphic types to the language of
types: $∀X:k.A(X)$, and type abstractions (Λ-abstractions) and applications to
the language of terms. It is also called System F, and it is equivalent
to propositional logic cite:barendregt92_typed.

#+begin_export latex
\[\begin{array}{ccccccccc}
types & ≔ & T & | & A → B  & | &     &   & ∀A.B \\
terms & ≔ & v & | & λx:A.t & | & a b & | & ΛA.t \\
values & ≔ &  &   & λx:A.t & | &     &   & ΛA.t \\
\end{array}\]
#+end_export

**** λΠ-calculus
Allowing types to depend on terms means that type of a function can depend on
its term-level arguments, hence dependent types, represented by the type
$Πa:A.B(a)$. This dependency is the reason for the name of dependently-typed
languages. This system is well-studied as the Logical Framework (LF)
cite:barendregt92_typed.

#+begin_export latex
\[\begin{array}{ccccccccc}
types & ≔ & T & | & A → B  & | &     &   & Πa:A.B \\
terms & ≔ & v & | & λx:A.b & | & a b & | & Πa:A.b \\
values & ≔ &  &   & λx:A.b & | &     &   & Πx:A.b \\
\end{array}\]
#+end_export

**** Pure type system
These systems can all be described by one set of typing rules instantiated with
a triple $(S, A, R)$. Given the set of sorts $S=\{⋆,□\}$ we can define relations
$A$ and $R$ where, for example, $A=\{(⋆,□)\}$ is translated to the axiom $⊢⋆:□$
by the rule *Start*, and $R=\{(⋆,□)\}$[fn:1] means that a kind can depend on a
type using the rule *Product*.

#+begin_export latex
\[\begin{array}{ccll}
S & ≔ & \{⋆,□\} & \text{set of sorts} \\
A & ⊆ & S×S   & \text{set of axioms} \\
R & ⊆ & S×S×S & \text{set of rules}
\end{array}\]
#+end_export

The typing rules in Figure ref:coc-rules apply to all the above-mentioned
type systems. The set $R$ exactly corresponds to the dimensions of the λ-cube,
so instantiating this type system with $R=\{(⋆,⋆)\}$ would produce the
λ→-calculus, whereas including all the dependencies $R=\{(⋆,⋆), (□,⋆),(⋆,□),
(□,□)\}$ produces the λΠω-calculus. If we also consider that the function arrow
$A→B$ is exactly equivalent to the type $Πa:A.B(a)$ if the variable $a$ is not
used in the expression $B(a)$, the similarity to Figure ref:simple-types should
be easy to see.

#+label:coc-rules
#+caption:Typing rules of a pure type system
#+ATTR_LaTeX: :options [!htb]
#+begin_figure latex
\centering
\begin{tabular}{cl}
\AxiomC{}
\RightLabel{$(s₁,s₂)∈A$}
\UnaryInfC{$⊢ s₁:s₂$}
\DisplayProof & \textsc{(Start)} \\[11pt]
\AxiomC{$Γ ⊢ A:s$}
\RightLabel{$s∈S$}
\UnaryInfC{$Γ,x:A ⊢ x:A$}
\DisplayProof & \textsc{(Var)} \\[15pt]
\AxiomC{$Γ ⊢ x : A$}
\AxiomC{$Γ ⊢ B : s$}
\RightLabel{$s∈S$}
\BinaryInfC{$Γ,y:B ⊢ x:A$}
\DisplayProof & \textsc{(Weaken)} \\[15pt]
\AxiomC{$Γ ⊢ f:Π_{x:A}B(x)$}
\AxiomC{$Γ ⊢ a:A$}
\BinaryInfC{$Γ ⊢ fa : B[x≔a]$}
\DisplayProof & \textsc{(App)} \\[17pt]
\AxiomC{$Γ,x : A ⊢ b:B$}
\AxiomC{$Γ ⊢ Π_{x:A}B(x) : s$}
\RightLabel{$s∈S$}
\BinaryInfC{$Γ ⊢ (λx : A. b) : Π_{x:A}B(x)$}
\DisplayProof & \textsc{(Abs)} \\[17pt]
\AxiomC{$Γ ⊢ A:s₁$}
\AxiomC{$Γ,x:A ⊢ B:s₂$}
\RightLabel{$(s₁,s₂,s₃)∈R$}
\BinaryInfC{$Γ ⊢ Π_{x:A}B(x) : s₃$}
\DisplayProof & \textsc{(Product)} \\[17pt]
\AxiomC{$Γ ⊢ a:A$}
\AxiomC{$Γ ⊢ A':s$}
\AxiomC{$A ⟶_β A'$}
\RightLabel{$s∈S$}
\TrinaryInfC{$Γ ⊢ a:A'$}
\DisplayProof & \textsc{(Conv)} \\[7pt]
\end{tabular}
#+end_figure

**** Universes
The notion of sorts and axioms can be generalized even more. Instantiating this
system with an infinite set of sorts $S=\{Type₀,Type₁,...\}$ instead of the set
$\{⋆,□\}$ and setting $A$ to $\{(Type₀, Type₁),\linebreak[1] (Type₁,Type₂),
...\}$ leads to an infinite hierarchy of /type universes. Proof assistants
commonly use such a hierarchy cite:bove08_atwork.

**** Type in Type
Going the other way around, simplifying $S$ to $S=\{⋆\}$ and setting
$A$ to $\{(⋆,⋆)\}$, leads to an inconsistent logic system called λ⋆, also called a
system with a /Type in Type/ rule. This leads to paradoxes similar to the Russel's
paradox in set theory.

In many pedagogic implementations of dependently-typed λ-calculi I saw, though,
this was simply acknowledged: separating universes introduces complexity but the
distinction is not as important for many purposes.

For the goal of this thesis--testing the characteristics of a runtime
system--the distinction is unimportant. In the rest of the text we will use the
inconsistent λ⋆-calculus, but with all the constructs mentioned in the preceding
type systems. We will now formally define these constructs, together with
several extensions to this system that will be useful in the context of
just-in-time compilation using Truffle, e.g., (co)product types, booleans, natural
numbers.

Proof assistants and other dependently-typed programming languages use systems
based on λΠω-calculus, which is called the Calculus of Constructions. They add
more extensions: induction and subtyping are common ones. We will discuss only a
subset of them in the following section, as many of these are irrelevant to the
goals of this thesis.

** Types
With the basic concepts introduced, we can move on to specifying the syntax and
semantics of the language that will be used for the implementation and
evaluation part of this thesis. While it is possible to derive any types using
only three constructs: Π-types (dependent product), Σ-types (dependent sum), and
$W\text{-types}$ (inductive types), that we have not seen so far; we will define
specific /"wired-in"/ types in addition to the Π- and Σ-types, as they are more
straightforward to both use and implement.

We will specify the syntax and semantics of each type at the same time. For
syntax, we will define the terms and values, for semantics we will use four
parts: type formation, a way to construct new types; term introduction
(constructors), ways to construct terms of these types; term elimination
(destructors), ways to use them to construct other terms; and computation rules
that describe what happens when an introduced term is eliminated. The algorithms
to normalize and type-check these terms will be mentioned in the following
chapter. In this section we will solely focus on the syntax and semantics.

*** Π-types
As mentioned above, the type $Πa:A.B$, also called the /dependent product type/
or the /dependent function type/, is a generalization of the function type $A→B$.
Where the function type simply asserts that its corresponding function will
receive a value of a certain type as its argument, the Π-type makes the value
available in the rest of the type. Figure ref:type-pi introduces its semantics;
they are similar to the typing rules of λ→-calculus function application, except
for the substitution in the type of $B$ in rule *Elim-Pi*.

#+label: type-pi
#+CAPTION: Π-type semantics
#+ATTR_LaTeX: :options [!htb]
#+begin_figure latex
\centering
\begin{tabular}{cc}
\multicolumn{2}{c}{%
\AxiomC{$Γ ⊢ A:⋆$}
\AxiomC{$Γ, x:A ⊢ B:⋆$}
\RightLabel{\textbf{(Type-Pi)}}
\BinaryInfC{$Γ ⊢ Πx:A.B$}
\DisplayProof
} \\[15pt]
\AxiomC{$Γ,a:A ⊢ b:B$}
\RightLabel{\textbf{(Intro-Pi)}}
\UnaryInfC{$Γ ⊢ λx.b : Πx:A.B$}
\DisplayProof
&
\AxiomC{$Γ ⊢ f : Πx:A.B$}
\AxiomC{$Γ ⊢ a:A$}
\RightLabel{\textbf{(Elim-Pi)}}
\BinaryInfC{$Γ ⊢ f a : B[x≔a]$}
\DisplayProof
\\[15pt]
\multicolumn{2}{c}{%
\AxiomC{$Γ, a:A ⊢ b:B$}
\AxiomC{$Γ ⊢ a:A$}
\RightLabel{\textbf{(Eval-Pi)}}
\BinaryInfC{$Γ ⊢ (λx:A.b)a ⟶_β b[x≔a]$}
\DisplayProof
}
\end{tabular}
#+end_figure

While a very common example of a Π-type is the length-indexed vector
$Π(n:ℕ). Vec(ℝ, n)$, it is also possible to define a function with a /"dynamic"/
number of arguments like in the following listing. It is a powerful language
feature also for its programming uses, as it makes it possible to e.g. implement
a well-typed function ~printf~ that, e.g., produces the function $Nat → Nat →
String$ when called as ~printf "%d%d"~. The following is an example of a function,
whose number of arguments changes based on the value of the first argument.

#+begin_export latex
\[\begin{array}{rcl}
succOrZero & : & Π(b:Bool). if b then (Nat→Nat) else Nat \\
succOrZero & = & Π(b:Bool). if b then (λx. x+1) else 0 \\[3pt]
succOrZero true 0 & ⟶_{βδ} & 1 \\
succOrZero false & ⟶_{βδ} & 0
\end{array}\]
#+end_export

**** Implicit arguments
The type-checker can infer many type arguments. Agda adds the concept of
implicit function arguments cite:bove08_atwork to ease the programmer's work and
mark inferrable type arguments in a function's type signature. Such arguments
can be specified when calling a function using a special syntax, but they are
not required cite:kovacs20_implicit. We will do the same, and as such we will
split the syntax of a Π-type back into three separate constructs, which can be
seen in Figure ref:syntax-pi.

#+label: syntax-pi
#+CAPTION: Π-type syntax
#+ATTR_LaTeX: :options [!htb]
#+begin_figure latex
\captionsetup{aboveskip=-3pt}
\[\begin{array}{cclcccll}
term & ≔ & a → b & | & (a:A)→b & | & \{a:A\}→b & \text{(abstraction)} \\
     & | & f a   & | &         & | & f \{a\}   & \text{(application)} \\
value & ≔ & Πa:A.b
\end{array}\]
#+end_figure

The plain /function type/ $A→B$ is simple to type but does not bind the value
provided as the argument $A$. The /explicit Π-type/ $(a:A)→B$ binds the value $a$
and makes it available to use inside $B$, and the /implicit Π-type/ $\{a:A\}→B$
marks the argument as one that type elaboration should be able to infer from the
surrounding context. The following is an example of the implicit argument
syntax, a polymorphic function $id$.

#+begin_export latex
\[\begin{array}{rclcl}
id         & : & \{A:⋆\}→A→A   & ≔ &          Π(x:A).x \\
id \{Nat\} & : & Nat→Nat & ⟶_{βδ} & λ(x:Nat).x \\
id 1       & : & Nat     & ⟶_{βδ} & 1
\end{array}\]
#+end_export

*** Σ-types
The Σ-type is also called the /dependent pair type/, or alternatively the
dependent tuple, dependent sum, or even the dependent product type.  Like the
Π-type was a generalization of the function type, the Σ-type is a generalization
of a product type, or simply a /pair/. Semantically, the Σ-type is similar to the
tagged union in C-like languages: the type $Σ(a:A).B(a)$ corresponds to a value
$(a,b)$, only the type $B(a)$ can depend on the first member of the pair. This
is illustrated in Figure ref:type-sigma, where the dependency can be seen in
rule *Intro-Sigma*, in the substitution $B[x≔a]$.

#+label: type-sigma
#+CAPTION: Σ-type semantics
#+begin_figure latex
\centering
\begin{tabular}{cc}
\multicolumn{2}{c}{%
\AxiomC{$Γ ⊢ A : ⋆$}
\AxiomC{$Γ, x : A ⊢ B : ⋆$}
\RightLabel{\textbf{(Type-Sigma)}}
\BinaryInfC{$Γ ⊢ Σ_{x : A}B : ⋆$}
\DisplayProof
} \\[15pt]
\multicolumn{2}{c}{%
\AxiomC{$Γ ⊢ a : A$}
\AxiomC{$Γ, x : A ⊢ B : ⋆$}
\AxiomC{$Γ ⊢ b : B[x ≔ a]$}
\RightLabel{\textbf{(Intro-Sigma)}}
\TrinaryInfC{$Γ ⊢ (a, b) : Σ_{x : A}B$}
\DisplayProof
} \\[15pt]
\AxiomC{$Γ ⊢ p : Σ_{x : A}B$}
\RightLabel{\textbf{(Elim-Sigma1)}}
\UnaryInfC{$Γ ⊢ π₁ p : A$}
\DisplayProof &
\AxiomC{$Γ ⊢ p : Σ_{x : A}B$}
\RightLabel{\textbf{(Elim-Sigma2)}}
\UnaryInfC{$Γ ⊢ π₂ p : B[x ≔ fst p]$}
\DisplayProof \\[15pt]
\multicolumn{2}{c}{%
\AxiomC{$Γ ⊢ a : A$}
\AxiomC{$Γ, x : A ⊢ B : ⋆$}
\AxiomC{$Γ ⊢ b : B[x ≔ a]$}
\RightLabel{\textbf{(Eval-Sigma1)}}
\TrinaryInfC{$Γ ⊢ π₁ (a, b) ⟶_ι a : A$}
\DisplayProof
} \\[15pt]
\multicolumn{2}{c}{%
\AxiomC{$Γ ⊢ a : A$}
\AxiomC{$Γ, x : A ⊢ B : ⋆$}
\AxiomC{$Γ ⊢ b : B[x ≔ a]$}
\RightLabel{\textbf{(Eval-Sigma2)}}
\TrinaryInfC{$Γ ⊢ π₂ (a, b) ⟶_ι b : B$}
\DisplayProof
}
\end{tabular}
#+end_figure

Above, we had a function that could accept different arguments based on the
value of the first argument. Below we have a type that simply uses Σ in place of
Π in the type: based on the value of the first member, the second member can be
either a function or a value, and still be a well-typed term.

#+begin_export latex
\[\begin{array}{rcl}
FuncOrVal & : & Σ(b:Bool). if b then (Nat→Nat) else Nat \\
(true, λx. x+1) & : & FuncOrVal \\
(false, 0) & : & FuncOrVal
\end{array}\]

#+end_export

**** Pair
Similar to the function type, given the expression $Σ(a:A).B(a)$, if $a$ does
not occur in the expression $B(a)$, then it is the non-dependent pair type. The
pair type is useful to express an isomorphism also used in general programming
practice: a conversion between a function of two arguments, and a function of
one argument that returns a function of one argument:

#+begin_export latex
\[\begin{array}{rclcll}
          &   & A × B → C   & ⇔ & A → B → C \\
    curry & ≔ & λ(f:A×B→C). &   & λ(x:A).λ(y:B). & f (x,y) \\
  uncurry & ≔ & λ(f:A→B→C). &   & λ(x:A×B). & f (π₁ x) (π₂ y)
\end{array}\]
#+end_export

**** Tuple
The n-tuple is a generalization of the pair, a non-dependent set of an arbitrary
number of values, otherwise expressible as a set of nested pairs: commonly
written as $(a₁, ..., aₙ)$.

**** Record
A record type is similar to a tuple, only its members have unique labels. In
Figure ref:type-record we see the semantics of a general record type, using the
notation $\{l_i=t_i\} : \{l_i:T_i\}$ and a projection $record.member$.

#+label: type-record
#+CAPTION: Record semantics
#+ATTR_LaTeX: :options [!htb]
#+begin_figure latex
\centering
\begin{tabular}{cc}
\multicolumn{2}{c}{%
\AxiomC{$∀i∈\{1..n\} Γ ⊢ Tᵢ:⋆$}
\RightLabel{\textbf{(Type-Rec)}}
\UnaryInfC{$Γ ⊢ \{lᵢ:Tᵢ^{i∈\{1..n\}}\}:⋆$}
\DisplayProof } \\[15pt]
\multicolumn{2}{c}{%
\AxiomC{$∀i∈\{1..n\} Γ ⊢ tᵢ : Tᵢ$}
\RightLabel{\textbf{(Intro-Rec)}}
\UnaryInfC{$Γ ⊢ \{lᵢ=tᵢ^{i∈\{1..n\}}\} : \{lᵢ:Tᵢ^{i∈\{1..n\}}\}$}
\DisplayProof } \\[15pt]
\multicolumn{2}{c}{%
\AxiomC{$Γ ⊢ t : \{lᵢ:Tᵢ^{i∈\{1..n\}}\}$}
\RightLabel{\textbf{(Elim-Rec)}}
\UnaryInfC{$Γ ⊢ t.lᵢ : Tᵢ$}
\DisplayProof } \\[15pt]
\multicolumn{2}{c}{%
\AxiomC{$∀i∈\{1..n\} Γ ⊢ tᵢ : Tᵢ$}
\AxiomC{$Γ ⊢ t : \{lᵢ:Tᵢ^{i∈\{1..n\}}\}$}
\RightLabel{\textbf{(Eval-Rec)}}
\BinaryInfC{$Γ ⊢ \{lᵢ=tᵢ^{i∈\{1..n\}}\}.lᵢ ⟶_ι tᵢ : B$}
\DisplayProof
}
\end{tabular}
#+end_figure

In Figure ref:syntax-sigma we have a syntax that unifies all of these concepts:
a Σ-type, a pair, an n-tuple, a named record. A non-dependent n-tuple type is
written as $A×B×C$ with values $(a,b,c)$. Projections of non-dependent tuples
use numbers, e.g., $p.1$, $p.2$, ... A dependent sum type is written in the same
way as a named record: $(a:A)×B$ binds the value $a:A$ in the rest of the type
$B$, and on the value-level enables the projection $obj.a$.

#+label: syntax-sigma
#+CAPTION: Σ-type syntax
#+ATTR_LaTeX: :options [!htb]
#+begin_figure latex
\[\begin{array}{cclcll}
term & ≔ & T₁×⋯×Tₙ     & | & (l₁:T₁)×⋯×(lₙ:Tₙ)×T_{n+1} & \text{(types)} \\
     & | & t.i         & | & t.lₙ            & \text{(destructors)} \\
     & | & (t₁, ⋯, tₙ) &   &                 & \text{(constructor)} \\
value & ≔ & (t₁, ⋯, tₙ)
\end{array}\]
#+end_figure

**** Coproduct
The sum type or the coproduct $A+B$ can have values from both types $A$ and $B$,
often written as $a:A⊢ inl A:A+B$, where $inl$ means "on the left-hand side of
the sum $A+B$". This can be generalized to the concept of /variant types/, with an
arbitrary number of named members; shown below, using Haskell syntax:

#+LATEX: \[data Maybe a = Nothing | Just a\]

For the purposes of our language, a binary sum type is useful, but inductive
variant types would require more involved constraint checking, so we will ignore
those, only using simple sum types in the form of $A+B$. This type can be
derived using a dependent pair where the first member is a boolean.

#+LATEX: \[Char+Int ≃ Σ(x:Bool). if x Char Int\]

*** Value types
**** Finite sets
Pure type systems mentioned in the previous chapter often use types like *0*, *1*,
and *2* with a finite number of inhabitants, where the type *0* (with zero
inhabitants of the type) is the empty or void type. Type *1* with a single
inhabitant is the unit type, and the type *2* is the boolean type. Also, the
infinite set of natural numbers can be defined using induction over *2*.
For our purposes it is enough to define a fixed number of types, though.

**** Unit
The unit type *1*, or commonly written as the 0-tuple "$()$", is sometimes used as a
universal return value. As it has no evaluation rules, though, we can simply add
a new type $Unit$ and a new value and term $unit$, with the rule $unit : Unit$.

**** Booleans
The above-mentioned type *2* has two inhabitants and can be semantically mapped to
the boolean type. In Figure ref:type-bool we introduce the values $true$ and
$false$, and a simple eliminator $cond$ that returns one of two values based on
the truth value of its argument.

#+label: type-bool
#+CAPTION: \texttt{Bool} semantics
#+ATTR_LaTeX: :options [htb]
#+begin_figure latex
\centering
\begin{tabular}{cc}
\multicolumn{2}{c}{%
\AxiomC{}
\RightLabel{\textbf{(Type-Nat)}}
\UnaryInfC{$⊢ Bool : ⋆$}
\DisplayProof
} \\[13pt]
\AxiomC{}
\RightLabel{\textbf{(Intro-True)}}
\UnaryInfC{$⊢ true : Bool$}
\DisplayProof &
\AxiomC{}
\RightLabel{\textbf{(Intro-False)}}
\UnaryInfC{$⊢ false : False$}
\DisplayProof
\\[13pt]
\multicolumn{2}{c}{%
\AxiomC{$Γ ⊢ a₁:A$}
\AxiomC{$Γ ⊢ a₂:A$}
\RightLabel{\textbf{(Elim-Bool)}}
\BinaryInfC{$Γ,x:Bool ⊢ if x a₁ a₂ : A$}
\DisplayProof
} \\[15pt]
\AxiomC{$Γ ⊢ a₁:A$}
\AxiomC{$Γ ⊢ a₂:A$}
\RightLabel{\textbf{(Eval-True)}}
\BinaryInfC{$Γ ⊢ cond true a₁ a₂ ⟶_ι a₁ : A$}
\DisplayProof &
\AxiomC{$Γ ⊢ a₁:A$}
\AxiomC{$Γ ⊢ a₂:A$}
\RightLabel{\textbf{(Eval-False)}}
\BinaryInfC{$cond false a₁ a₂ ⟶_ι a₂ : A$}
\DisplayProof
\end{tabular}
#+end_figure
#+latex: \vspace*{-.5cm}

**** Natural numbers
The natural numbers form an infinite set, unlike the above value types.  On
their own, adding natural numbers to a type system does not produce
non-termination, as the recursion involved in their manipulation can be limited
to primitive recursion as e.g., used in Gödel's System T cite:bove08_atwork.
The constructions introduced in Figure ref:type-nat are simply the constructors
$zero$ and $succ$, and the destructor $natElim$ unwraps at most one layer of
$succ$.

#+label: type-nat
#+CAPTION: \texttt{Nat} semantics
#+ATTR_LaTeX: :options [htb]
#+begin_figure latex
\centering
\begin{tabular}{cc}
\multicolumn{2}{c}{%
\AxiomC{}
\RightLabel{\textbf{(Type-Nat)}}
\UnaryInfC{$⊢ Nat : ⋆$}
\DisplayProof
} \\[11pt]
\AxiomC{}
\RightLabel{\textbf{(Intro-Zero)}}
\UnaryInfC{$⊢ zero : Nat$}
\DisplayProof &
\AxiomC{$Γ ⊢ n : Nat$}
\RightLabel{\textbf{(Intro-Succ)}}
\UnaryInfC{$Γ ⊢ succ n : Nat$}
\DisplayProof
\\[13pt]
\multicolumn{2}{c}{%
\AxiomC{$Γ ⊢ a₁:A$}
\AxiomC{$Γ,n:Nat ⊢ a₂:A$}
\RightLabel{\textbf{(Elim-Nat)}}
\BinaryInfC{$Γ,x:Nat ⊢ natElim x a₁ (λx.a₂)$}
\DisplayProof
} \\[15pt]
\multicolumn{2}{c}{%
\AxiomC{$Γ ⊢ a₁:A$}
\AxiomC{$Γ,n:Nat ⊢ a₂:A$}
\RightLabel{\textbf{(Eval-Zero)}}
\BinaryInfC{$Γ ⊢ natElim zero a₁ (λx.a₂) ⟶_ι a₁ : A$}
\DisplayProof
} \\[15pt]
\multicolumn{2}{c}{%
\AxiomC{$Γ ⊢ a₁:A$}
\AxiomC{$Γ,n:Nat ⊢ a₂:A$}
\AxiomC{$Γ ⊢ n:Nat$}
\RightLabel{\textbf{(Eval-Succ)}}
\TrinaryInfC{$natElim (succ n) a₁ (λx.a₂) ⟶_ι a₂[x≔n] : A$}
\DisplayProof
}
\end{tabular}
#+end_figure

** Remaining constructs
These constructs together form a complete core language capable of forming and
evaluating expressions. Already, this would be a usable programming
language. However, the /surface language/ is still missing: the syntax for
defining constants and variables, and interacting with the compiler.

**** Local definitions
The λ-calculus is, to use programming language terminology, a purely functional
programming language: without specific extensions, any language construct is an
expression. We will use the syntax of Agda, and keep local variable definition
as an expression as well, using a ~let-in~ construct, with the semantics given in
Figure ref:let-in.

#+label: let-in
#+CAPTION: \texttt{let-in} semantics
#+ATTR_LATEX: :options [htb]
#+begin_figure latex
\captionsetup{aboveskip=-3pt}
\begin{prooftree}
\AxiomC{$Γ ⊢ a : A$}
\AxiomC{$Γ,x:A ⊢ b : B$}
\RightLabel{\textbf{(Type-Let)}}
\BinaryInfC{$Γ ⊢ \text{let} x=a \text{in} b:B$}
\end{prooftree}
\begin{prooftree}
\AxiomC{$Γ ⊢ v:A$}
\AxiomC{$Γ,x:A ⊢ e:B$}
\RightLabel{\textbf{(Eval-Let)}}
\BinaryInfC{$\text{let} x=v \text{in} e ⟶_ζ e[x≔v]$}
\end{prooftree}
#+end_figure

**** Global definitions
Global definitions are not strictly necessary, as with local definitions and the
fixed-point combinator we could emulate them. However, global definitions will
be useful later in the process of elaborations, when global top-level
definitions will separate blocks that we can type-check separately. We will add
three top-level expressions: a declaration that only
assigns a name to a type, and a definition with and without type. Definitions
without types will have them inferred.

#+begin_export latex
\[\begin{array}{ccl}
top & ≔ & id : term \\
    & | & id : term = term \\
    & | & id = term \\
\end{array}\]
#+end_export

**** Holes
A construct that serves solely as information to the compiler and will not be
used at runtime is a /hole/. It can take the place of a term in an expression and
marks the missing term as one to be inferred ("filled in") during
elaboration[fn:2]. In fact, the syntax for a global definition without a type
will use a hole in place of its type. The semantics of a hole are omitted on
purpose as they would also require specifying the type inference algorithm.

#+begin_export latex
\[\begin{array}{ccl}
term & ≔ & \_
\end{array}\]
#+end_export

**** Interpreter directives
Another type of top-level expressions is a pragma, a direct command to the
compiler. We will use these when evaluating the time it takes to normalize or
elaborate an expression, or when enabling or disabling the use of "wired-in"
types, e.g. to compare the performance impact of using a Church encoding of
numbers versus a natural type that uses hardware integers. We will once again
use the syntax of Agda:

#+begin_export latex
\[\begin{array}{ccl}
top & ≔ & \{-\# BUILTIN id \#-\} \\
    & | & \{-\# ELABORATE term \#-\} \\
    & | & \{-\# NORMALIZE term \#-\} \\
\end{array}\]
#+end_export

The syntax and semantics presented here altogether comprise a working
programming language. A complete listing of the syntax and semantics is included
in Appendix ref:spec.

This syntax now needs to be translated into a recognizer (a parser and a lexer),
and the semantics into a type-checker and an evaluator for the language. A
simplified grammar, translated from the syntax, is included in Listing
ref:grammar. Compared to the previous syntax specifications, the grammar also
needs to encode the precedence and associativity of each construct.

With this, the language specification is complete, and we can move on to the
next part, implementing a type-checker and an interpreter for this language.

#+label: grammar
#+caption: A simplified version of the grammar (written using ANTLR syntax)
#+begin_src antlr
  FILE : STMT (STMTEND STMT)* ;
  STMT : '{-#' ID+ '#-}'
       | ID ':' EXPR
       | ID (':' EXPR)? '=' EXPR
       ;
  EXPR : 'let' ID ':' EXPR '=' EXPR 'in' EXPR
       | 'λ' LAM_BINDER '.' EXPR
       | PI_BINDER+ '→' EXPR
       | ATOM ARG*
       ;
  LAM_BINDER
       : ID | '_' | '{' (ID | '_') '}' ;
  PI_BINDER
       : ATOM ARG*
       | '(' ID+ ':' EXPR ')'
       | '{' ID+ ':' EXPR '}'
       ;
  ARG
       : ATOM
       | '{' ID ('=' TERM)? '}'
       ;
  ATOM : '(' ID ':' EXPR ')' '×' EXPR
       | EXPR '×' EXPR
       | '(' EXPR (',' EXPR)+ ')'
       | '(' EXPR ')'
       | ID '.' ID
       | ID | NAT | 'Unit' | | '_'
       ;
  STMTEND : ('\n' | ';')+ ;
  ID : [a-zA-Z] [a-zA-Z0-9] ;
  SKIP : [ \t] | '--' [^\r\n]* | '{-' [^#] .* '-}' ;
#+end_src

* Bibliography                                                :ignoreheading:
bibliographystyle:abbrv
bibliography:bibliography.bib
* Footnotes
[fn:2] Proof assistants also use the concept of a metavariable, often with the syntax $?α$.
[fn:1] The elements of $R$ are written as $(s₁,s₂)$, which is equivalent to $(s₁,s₂,s₂)$.

