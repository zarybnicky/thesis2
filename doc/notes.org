* Writing
presents the result of my research into dependent types and lambda calculus, sourced from 
performance analysis based on Gross, Idris 2 development

abstract - primarily for evaluation, not too suitable for elab

- elaboration
  - inlining, unfolding

- originally separate architectures, now sharing elaboration with non-Truffle impl
  - rewritten the non-Truffle impl to use Truffle concepts as well,
  - Enso came out, many optimizations
  - Enso optimized for runtime, computationally-intensive applications
  - had Term generation inline
  - now separated out a "compilation" stage with pluggable stages. Term is "executable code", can be optimized λ-merging, ...
  - still needs to duplicate evaluation logic inside, especially App
  - CONTEXTS: local, top, meta, builtin

- problem: working blindly, testable only using the polyglot interface, as
  compilation is not accessible without a Language, and a Language is not
  accessible without a Polyglot context.
- thus, unit tests possible only for non-Truffle parts of the language

- Closures
  - all closures are now compiled
  - top definitions + meta solutions have closures as well, instantiated with current environment
  - each closure has an arity equal to the number of currently relevant binders
  - eval-apply, closure invocation decides whether to PAP (requires type-processing), invoke, or over-apply
  - each instantiation inside elaboration code maps to a single closure, as elaboration + normalization works with single-argument λs
  - forcing a spine is the exception
  - storing the environment inside an array would be simpler but, in theory, using the Frame should allow Truffle to optimize better
  - EXAMPLES of code and of FLOW!!!
  - VPi(n, Closure(tm))
  - VPi(VPi(n, Closure([n'], tm)) -> inst -> reconstruct the inner Pi
  - Top entry contains a Value - a fresh context, the Term is only for pretty()

- Typed metas
  - previously, untyped metas were sufficient, now to produce arities, we need typed meta-variables
  - rewriting of unification

- polyglot: not a Foreign construct, unfortunately, but
  - BUT show a eval(Unit) -> eval(id).execute(unit)
  - using both engines

- evaluation
  - numbers, snippets of workload code
    - SIMPLIFY benchmarks, remove STLC interpreter or what not
  - list possible optimizations
    - abstract machines are often used (lazy G-machine, Epigram)
    - type erasure
    - unboxed values for Truffle
    - λ-merging - requires elaboration changes
    - static code flow analysis (will we apply, or pap?), as well
    - low-level optimizations
      - unfolding recursive algorithm into explicit stack-based one
      - pair representation - nested pairs -> arrays, OSM
    - renaming and including only free variables - but! indices/levels mean that we can refer to arbitrary values in the general case
  - mention rewrite again (previous version had even worse performance)
  - JIT not suitable for elaboration, many small expressions
  - JIT very suitable for evaluation, so even it JIT did not perform well during NbE and typing, Enso uses Truffle for its evaluation speed
  - More sharing (CSE) would obviate the need for a JIT even more
  - re-adding lazy evaluation would speed up computations like const 1 (fib 100)
  - COMPARE:
    - agda, idris, coq, montuno (whole program runtime, JIT averaged over 100 invocations, others are non-JIT)
    - constant factors: empty program runtime
    - montuno with both "compilers", compare Nat built-ins
  - MENTION:
    - OOP for name resolution: static references to Metas, can be replaced using a la IOVars
    - Lazy evaluation is impractical, but possible (see FastR)
    - NbE is impractical for Truffle implementation (function invocation overhead) compared to GHC and similar abstract machines
    - what's the fast and slow path in Truffle with NbE???
    - overhead of lazy evaluation on small terms vs eager evaluation of large terms!
    - TESTING is only possible via the POLYGLOT interface - originally, only for demo purposes, but necessary!
- discussion
  - normalization-bench, Scala results
  - LIMITATIONS of my solution - incomplete implementation, insufficient tests, likely bugs to be found
  - Cadenza follow-up unsuccessful, it did not use NbE

- main contribution of this thesis is X

* Tasks
- nix installation + nix develop + gradle + repl
- explain the need for make repl
- Include DEMO REPL session - a video using ASCIInema (id, :print, const, const {Unit} const Unit, const id)
- Document CLI commands
- Add remaining CLI commands
- REPL command completion, partial command recognition

- úklid kódu, export na GH, link na GH do textu, PDF a kód a video na CD

- Compile syntax & semantics
- fill in program/data flow in Truffle
- fix program/data flow in Pure

- Force compilation, get graphs, include in text/motivational pic

- Include Bool, natElim, cond, eq, leq, geq
- write Fib
- test Fib
- test effect of lazy eval (with and without Thunk enabled)
- test effect of nat repr (builtin opaque Nat)
- test effect of JIT (engines)
- perhaps fix from LetRec from Cadenza?
