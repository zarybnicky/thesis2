* (front matter)                                              :ignoreheading:
#+LANGUAGE: en
#+OPTIONS: texht:nil toc:nil author:nil ':t H:4 num:3
#+LATEX_CLASS: article
#+LATEX_CLASS_OPTIONS: [a4paper]
#+BIND: org-latex-prefer-user-labels t
#+BIND: org-latex-default-figure-position "htb"
#+LATEX_HEADER:\usepackage{fontspec}
#+LATEX_HEADER:\setmainfont{texgyrepagella}[Ligatures=TeX, Extension=.otf, UprightFont=*-regular, BoldFont=*-bold, ItalicFont=*-italic, BoldItalicFont=*-bolditalic,]
#+LATEX_HEADER:\setmonofont{texgyrecursor-regular.otf}
#+LATEX_HEADER:\usepackage{unicode-math}
#+LATEX_HEADER:\setmathfont{texgyrepagella-math.otf}
#+LATEX_HEADER:\setmathfont{XITSMath-Regular.otf}[range={"2A3E}, BoldFont=XITSMath-Bold.otf, ]
#+LATEX_HEADER:\usepackage{subcaption}
#+LATEX_HEADER:\usepackage{bibentry}
#+LATEX_HEADER:\usepackage{url,color,multirow}
#+LATEX_HEADER:\usepackage{microtype}
#+LATEX_HEADER:\usepackage{amsmath}
#+LATEX_HEADER:\usepackage{amssymb}
#+LATEX_HEADER:\usepackage{minted}
#+LATEX_HEADER:\setminted{fontsize=\small}
#+LATEX_HEADER:\usepackage{tikz}
#+LATEX_HEADER:\usepackage{tikz-cd}
#+LATEX_HEADER:\usepackage{bussproofs}
#+LATEX_HEADER:\usetikzlibrary{arrows.meta,positioning}
#+LATEX_HEADER:\usepackage[colorinlistoftodos]{todonotes}
#+LATEX_HEADER:\let\emph\textit
#+LATEX:\setlength{\parskip}{0pt}
* URI language (Incremental compilers)
- AST representation, tree representation
- my contributions, perhaps itemized
- Partial Escape Analysis - variable localization, eliminate heap allocation
  when unnecessary, (Scalar Replacement)
- project structure - package list with brief description
- maybe split Truffle practicals into "Basic" and "Advanced" - make it work,
  then make it fast - use nodes, then elaborate - or the other way around, list
  possible concepts/approaches from simplest to most complex, sketch the
  mapping, describe the implementation
- Shape = mapping Property ⟶ Location, Shape.newInstance == DynamicObject
- interop: ForeignToLocalTypeNode
- thread-safety of objects: by default Truffle is not safe, explicit synchronization

* TruffleClojure
- Graal IR is a directed graph structure in static single assignment form
- Truffle+Graal means that languages reuse JVM's features: garbage collection, optimization
- API based on Node; Frame stores the transient state of function activation:
  local variables, arguments passed to the function, intermediate results, shape
  described by FrameDescriptor, data in the backend stored in Object[] or if
  primitive types only in long[] (and converted)
- I might want to implement envs as tries? Not arrays nor linked lists? Need to try
- Truffle feature description - only 1 para each! Short & sweet
- I must have a program execution flow
- I also need a "data shape flow" (src, pre, term, val)
- each method impl is a root node, kept in bundles of callTargets by a ClojureFn
- closures - by a reference to the outer materializedFrame
- macros expanded during parse time, arguments not evaluated
- macroexpand function that expands macros
- separate section with a heading+listing+description of each special form (do
  we need this?)
- TCO - maybe describe a trampoline? + a graph

* R via aggressive speculation
- contributions: "we describe [techniques]", "we show [their effectiveness]",
  "we demonstrate [ours]".
- Truffle -  simple list with one sentence overview; then one parahraph each,
  then subheadings - copy into mine!
- immediately following that, how they use the features (assumptions)

* Partial evaluation
- constructs a complete program graph spanning across function calls, optimizes
- profile-based optimizing interpreters:
  - run a guest language function a few times
  - gather profiling information: calls performed, data types used
  - specialize the interpreter, generate code

profiles, assumptions, specializations:
- similar tools
- profiles for local, monomorphic properties, does not speculate again
- assumptions for non-local speculation, can be triggered from outside
- specializations for local, polymorphic, speculates again

AST interpreters:
- AST = abstract syntax tree, produced by a parser
- a node can be executed (in a single way)
- direct AST interpretation is slow, but usually easy to write

Inter-node control flow - use exceptions

Frame
- is an object on the heap, allocated in the function prologue
- compiler eliminates the allocation
- FrameDescriptor - layout of the frame

TruffleBoundary - to avoid inlining large methods: println, database access, ...

Assertions to check the compiler isCompilationConstant, neverPartOfCompilation

Inline caches - complex feature, 

Separation of concerns in function call:
- Invoke node evaluates function and its arguments, calls dispatch
- Dispatch node builds the inline cache
- Direct/Indirect call node (Truffle) calls the CallTarget which calls the RootNode

Inlining vs splitting
- inlining replaces a call with a copy of the graph it stands for
- inlining works on the AST level
- splitting produces a fresh callTarget, monomorphic code

Tools:
- tag: an annotation for debugging tools, can be custom
- probe: a program location that emits events
- event: marks when execution has entered of left a node
- instrument: receives events
- WrapperNode: around a node, intercepts events, contains a Node and a ProbeNode
- cite "We can have it all" van de vanter

Oracle integration
multi-language REPL

* Truffle (tasks)
- what's up, some languages
- required restructuring: compiler structure, hard parts, mention other
  languages throughout
- providing more information:
  - specialization, constants, invalidation

Split the info dump
= make it run, then make it fast

Paragraph headers as structure of the larger blocks after an itemized overview

"Truffle provides:"
1. ~Node~, a superclass for AST nodes that implements AST rewriting mechanisms
2. ~Frame~, stack frame mechanism
3. ~RootNode~, ~CallTarget~, ~CallNode~, a set of classes involved in function dispatch
4. compiler directives and profiling support for the Graal compiler
5. an polyglot object storage model
6. a DSL as a set of annotations for specializations, caching, implicit conversions

* Push/enter
cite:marlow04_fast_curry

- function application in languages with currying can be implemented using two
  evaluation models, push/enter and eval/apply
- compiled implementations should use eval/apply
- push/enter - arguments are pushed onto the stack, fun is entered, fun checks
  the number of arguments
- eval/apply - caller evaluates the function and applies it to the correct
  number of arguments
- need to distinguish known and unknown function calls,
- formalism uses heap objects FUN(●≥0), PAP(●(f)≥●≥1), CON(constructor), THUNK,
  BLACKHOLE
- + unboxed values not wrapped in any of these
- Rules: thunk→blackhole, blackhole→val, exact, over, under, thunkCall, papCall, retCall
- Truffle in theory supports both, but eval/apply plays better to the
  optimization where a calltarget should be as specialized as possible
- unboxing requires instanceof checks, we want to specialize/split
- push/enter means we need to copy arguments into an array

* Renaissance
cite:prokopec19_renaissance

- a set of benchmarks and measurement tools
- measures: synchronized, object.wait, object.notify, atomic ops, park
  operations, average cpu usage, cache misses, objects allocated, arrays
  allocated, method calls, dynamic method calls
- needs us to package it in a special way, but useful to compare between truffle
  optimization versions
- https://github.com/Gwandalff/krun-dsl-benchmarks is an alternative that has
  examples with Truffle, measures only s/op

* Program flow diagram
$Repl OR files \xrightarrow{①} main ⟷ parser ⟶ translator ⟶ TruffleAST$

Stage ① does this.

* Bibliography
bibliographystyle:abbrv
bibliography:bibliography.bib
